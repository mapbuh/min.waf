[main]
# IP address to listen to
host=127.0.0.1
# Port to listen to
port=9009
# Lock file filename
lockfile=/var/run/min.waf.pid
# Enable packet inspection
inspect_packets = True
# inspect the first n bytes of the request only
max_inspect_size = 32768

# stats for bad http_status and stealing are calculated over this time frame (in seconds)
time_frame = 300
# ban time for offending IPs (in seconds)
ban_time = 600

# url to download ip blacklist from
# should be a plain text file with one ip/network per line
ip_blacklist = https://raw.githubusercontent.com/bitwire-it/ipblocklist/refs/heads/main/ip-list.txt
# refresh time for ip blacklist (in seconds)
ip_blacklist_refresh_time = 7200

# new line separated list of ip/networks to always whitelist
# whitelist = 
#       1.2.3.4
#       1.2.3.5
whitelist = 

# expire time for whitelist from triggers
whitelist_expiration = 86400

# method to use when banning IPs: iptables or internal
# iptables is recommended for production use, while internal
# can be used to log and analyze attacks
ban_method = iptables
iptables_chain = MINWAF

# ratio of bad http status codes (4xx, 5xx) to total requests, excluding static files
http_status_bad_threshold = 0.51
http_status_min_count = 20
http_status_good =
    200
    206
    304
    499

# ignore_statuses: list[int] = [301, 302, 303, 304, 307, 308]
http_status_ignore =
    301
    304


# wait at list this many seconds between first and last request
steal_over_time = 10

# if total stolen time is more than this, consider it stealing
steal_total = 10

# if ratio of stolen/available time is more than this, consider it stealing
steal_ratio = 0.3

# static files are ignored when deciding which IPs to ban
static_files: =
    .css
    .eot
    .gif
    .ico
    .jpeg
    .jpg
    .js
    .json
    .mp3
    .mp4
    .ogg
    .otf
    .png
    .svg
    .ttf
    .txt
    .wav
    .webm
    .woff
    .woff2
    .xml

# these files are with bigger weight when deciding which IPs to ban
dynamic_files =
    .asp
    .aspx
    .bin
    .cgi
    .dll
    .exe
    .jsp
    .php
    .pl
    .py
    .rb
    .sh


# when these triggers are matched, the IP is whitelisted
#[whitelist_trigger.example_1]
#status = 200
#path = /admin/dashboard
#host = example.com
#
#[whitelist_trigger.example_2]
#status = 200
#path = /admin/reports/index
#host = example.com
#
#[whitelist_trigger.wordpress_example]
#status = 200
#path = /wp-admin/
#host = wordpress.example.com

url_stats = True
ua_stats = True

# requesting these result in immediate bans if http_status is 404 or 500
known_attacks =
    .git/credentials
    /.aws/config
    /.aws/credentials
    /.env.backup
    /.env.dev
    /.env.local
    /.env.production
    /.env.staging
    /.env.test
    /.env
    /.git/config
    /.htpasswd
    /222.php
    /abcd.php
    /alfa.php
    /alphanew.php
    /atomlib.php
    /aws-secret.yaml
    /cmd.php
    /config/aws.yml
    /enclass.php
    /gifclass.php
    /ioxi-o.php
    /lock360.php
    /lv.php
    /nc4.php
    /shell.php
    /system_log.php
    /vee.php
    /admin.php
    /install.php
    /phpinfo.php
    /wp-admin
    /wp-content/plugins/hellopress/wp_filemanager.php
    /wp-includes/ID3/license.txt
    /wp-includes/wlwmanifest.xml
    /wp-login.php
    /xmlrpc.php

[bots]
good_bots =
    https://ad.min.solutions
    https://www.babbar.tech/crawler
    https://developers.facebook.com/docs/sharing/webmasters/crawler
    http://www.facebook.com/bot.html
    http://www.facebook.com/externalhit_uatext.php
    http://mj12bot.com/
    Monit/5.33.0
    http://docs.sentry.io/product/alerts/uptime-monitoring/
    via ggpht.com GoogleImageProxy
bad_bots =
    Mozlila/5.0
    python-urllib
    python-requests
    python-http
    aiohttp/
    Go-http-client/
    libredtail-http

[bots.bing]
    user_agent = Bingbot
    ip_ranges_url = https://www.bing.com/toolbox/bingbot.json
    action = allow

[bots.duckduckgo]
    user_agent = DuckDuckBot
    ip_ranges_url = https://duckduckgo.com/duckduckbot.json
    action = allow
#    user_agent: Google
[bots.google]
    user_agent = Google
    ip_ranges_url = https://developers.google.com/static/search/apis/ipranges/googlebot.json
    action = allow

[bots.oai-gptbot]
    user_agent = GPTBot
    ip_ranges_url = https://openai.com/gptbot.json
    action = allow

[bots.oai-searchbot]
    user_agent = OAI-SearchBot
    ip_ranges_url = https://openai.com/searchbot.json
    action = allow


[signatures]
sql_injections = 
    UNION SELECT
    SELECT * FROM
    DROP TABLE
    INSERT INTO
    UPDATE SET
    DELETE FROM
    OR '1'='1
    OR "1"="1"
    OR 1=1

php_injections = 
    system(
    exec(
    shell_exec(
    passthru(
    popen(
    proc_open(
    eval(
    assert(
    preg_replace(
    create_function(
    {pboot:if(

node_injections = 
    require(
    require_once(
    include(
    include_once(
    process.binding(
    exec(
    execSync(
    child_process.spawn(
    fs.readFileSync(
    fs.writeFileSync(
    new Function(

[dev]
profiling = False
debug = False

[log]
bans = True
blacklist = False
whitelist = False
good_bots = False
bot_whitelist = False
bad_bots = False
#requests = /var/log/min.waf_requests.log
requests =
#contents = /var/log/min.waf_contents.log
contents =
